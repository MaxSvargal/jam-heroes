package CreepCampGroup

import LinkedList
import CreepsList
import MapState
import RegionsList

public class CreepCampGroup
	constant p = players[PLAYER_NEUTRAL_AGGRESSIVE]
	constant LinkedList<int> unitIds = new LinkedList<int>()
	int warlordId
	int onMapWarlordId
	unit onMapWarlord
	group units

	construct(vec2 pos)
		// get pos distance and set level increased by distance
		let lvlIncrease = calcLevelIncByDistance(pos)
		let lvl = mapState.getIncreasedLevel().toInt() + lvlIncrease
		print("selected level: " + lvl.toString() + " increased " + lvlIncrease.toString())
		warlordId = getRandomWarlordIdOfLevel(lvl)
		onMapWarlordId = getOnMapUnitIdByBattleId(warlordId)
		onMapWarlord = createUnit(p, onMapWarlordId, pos, angle(220))

		// preform creeps based on strength of hero? In that case move this to createGroupAtRect()
		let creepId = getRandomRegularIdOfLevel(lvl)
		for i = 0 to GetRandomInt(2, 8)
			unitIds.add(creepId)
	
	function calcLevelIncByDistance(vec2 pos) returns int
		let min = -bottomOfMap.y
		let max = topOfMap.y
		let distance = pos.distanceTo(bottomOfMap)
		return ((min + max) * ((distance / 2) * 0.000000001)).toInt()

	function createGroupAtRect(rect r) returns group
		let iterator = unitIds.iterator()
		let g = CreateGroup()
		for u from iterator
			g.addUnit(createUnit(p, u, r.randomPoint(), angle(220)))
		g.addUnit(createUnit(p, warlordId, r.randomPoint(), angle(220)))

		iterator.close()
		units = g
		return g

	function isGroupAlive() returns boolean
		var isAnyAlive = false
		for u in units
			if u.isAlive()
				isAnyAlive = true
		return isAnyAlive

	function getOnMapUnit() returns unit
		return onMapWarlord

	ondestroy
		onMapWarlord.kill()
		destroy unitIds // TODO: CHECK
		// destroy this

