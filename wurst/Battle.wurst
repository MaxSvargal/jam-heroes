package Battle

import OrderIds
import ClosureTimers
import BattleArea
import Players
import CreepCamp
import CreepCampGroup
import DropTables
import HashSet
import PlayerConfigurator
import LinkedList
import initlater IncomeBuildings

public class Battle
	constant playersInBattle = new HashSet<PlayerConfigurator>()
	player triggerPlayer
	BattleArea battleArea
	CreepCamp creepCamp
	IncomeBuilding incomeBuilding
	CreepCampGroup campGroup

	construct(player triggerPlayer, CreepCampGroup campGroup, BattleArea battleArea, CreepCamp creepCamp)
		_construct(triggerPlayer, campGroup, battleArea, creepCamp, null)

	construct(player triggerPlayer, CreepCampGroup campGroup, BattleArea battleArea, IncomeBuilding incomeBuilding)
		_construct(triggerPlayer, campGroup, battleArea, null, incomeBuilding)

	protected function _construct(
		player triggerPlayer,
		CreepCampGroup campGroup,
		BattleArea battleArea,
		CreepCamp creepCamp,
		IncomeBuilding incomeBuilding
	)
		this.battleArea = battleArea
		this.campGroup = campGroup
		this.triggerPlayer = triggerPlayer
		this.creepCamp = creepCamp
		this.incomeBuilding = incomeBuilding
		playerEnterInBattle(triggerPlayer)
		createCampGroup()
		listenForState()

	private function isAllPlayersAllies() returns bool
		let alliesStates = new LinkedList<bool>()
		let playersIterator = playersInBattle.iterator()
		for p from playersIterator
			alliesStates.add(triggerPlayer.isAllyOf(p.getPlayer()))
		playersIterator.close()
		let isNotAllAllies = alliesStates.has(false)
		destroy alliesStates
		return not isNotAllAllies

	private function checkAndSetPlayersStates() returns bool
		let playersIterator = playersInBattle.iterator()
		for p from playersIterator
			if not p.isAllGroupAlive()
				print("battle defeat")
				p.battleDefeat()
				playersInBattle.remove(p)
			else if isAllPlayersAllies()
			and not campGroup.isGroupAlive()
				p.battleVictory()
				playersInBattle.remove(p)
				// TODO: check for that works
				if creepCamp != null
					creepCamp.toRestore()
				// TODO: drop items on the map and hero needs to move to exit
				// TODO: move method to player instead of droptable?
				dropRandomItemAtPos(p.castleHeroPoint)
				//dropRandomItemAtPos(campGroup.warlord.getPos())
		playersIterator.close()
		return playersInBattle.size() == 0

	private function listenForState()
		doPeriodically(2) cb ->
			if checkAndSetPlayersStates()
				destroy cb
				destroy this

	function createCampGroup()
		// TODO: get battle area by tile under creep
		campGroup
			.createGroupAtRect(battleArea.enemiesStartPoint.withRadiusRect(300))
			..pointOrderById(Orders.attack, battleArea.heroStartPoint)

	function dropRandomItemAtPos(vec2 pos) returns item
		let itemId = new GenerateDropTable().getDropTable().getRandomItem()
		if itemId != 0
			return createItem(itemId, pos)
		else
			return null

	function playerEnterInBattle(player p)
		print("player enter " + p.getName() + p.getId().toString())
		print("playersInstances " + playersInstances.size().toString())
		let playerInstance = playersInstances.get(p.getId())
		print("playerEnterInBattle " + playerInstance.getPlayer().getName())
		if playerInstance != null
			playerInstance.startBattleAt(battleArea.heroStartPoint)
			playersInBattle.add(playerInstance)

	ondestroy
		if incomeBuilding != null
			incomeBuilding.setOwner(triggerPlayer)
			// incomeBuilding.setOwner(players[1])
		battleArea.clean()
		destroy campGroup
		destroy playersInBattle