package PlayerInstance

import ClosureEvents
import ClosureTimers
import UnitIds
import InstantDummyCaster
import Orders

import BuildingToUnitRelations
import HeroesList
import PlayersSpawnPoints

import Laboratory
import Tavern
import Selector
import UnitBuildPlaceSmall
import UnitBuildPlaceLarge

import ArmorRecieptsShop
import ArmorShop
import MagicArmorShop
import PotionsShop
import RareRecieptsShop
import WeaponShop

import RecoveryDebuff
import MoveToCastle
import initlater TheEscape

public class PlayerInstance
	protected constant player p
	group groupInBattle
	unit hero
	unit heroOnMap
	rect castleRect
	vec2 selectHeroArea
	vec2 onGlobalMapPos
	vec2 castleHeroPoint
	
	construct(player pl)
		p = pl
		initGroupBuildingPlaces()
		createUnit(p, SELECTOR_ID, gg_rct_InitialPos.getCenter(), angle(200))
		p.setCameraPosition(gg_rct_InitialPos.getCenter())

		onGlobalMapPos = getRandomSpawnPoint()

		EventListener.add(EVENT_PLAYER_UNIT_SELL) ->
			onHeroBought(GetSellingUnit(), GetSoldUnit())

		EventListener.add(EVENT_PLAYER_UNIT_SPELL_CAST) ->
			if GetTriggerPlayer() == p
				let abilId = GetSpellAbilityId()
				if abilId == MOVE_TO_CASTLE_ID
					moveToCastle()
				if abilId == MOVE_TO_GLOBAL_MAP_ID
					moveToGlobalMap()

		// Debuff logic
		EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
			addDebuffToBuildOnUnitDeath(GetTriggerUnit())

	function setVisibleRect(rect rectForVisible)
		CreateFogModifierRectBJ(true, p, FOG_OF_WAR_VISIBLE, rectForVisible)

	function setPositionOfHeroInCastle(rect pos)
		castleHeroPoint = pos.getCenter()

	// function createShopsOnRects(rect commonShopPos, rect recieptsShopPos)
	// 	createUnit(p, COMMON_SHOP_ID, commonShopPos.getCenter(), angle(0))
	// 	createUnit(p, RECIEPTS_SHOP_ID, recieptsShopPos.getCenter(), angle(0))

	function setCastleRect(rect castleRect)
		this.castleRect = castleRect

	function createShops()
		// 0deg is right
		// 90deg is top
		// 180deg is left
		// 270deg is bottom
		// <- x ^ y
		let castleCenter = castleRect.getCenter()
		let posTopRight0 = vec2(castleRect.getMaxX(), castleRect.getMaxY()).moveTowards(castleCenter, 300)
		let posTopRight1 = vec2(castleRect.getMaxX() - 300, castleRect.getMaxY()).moveTowards(castleCenter, 300)
		let posTopRight2 = vec2(castleRect.getMaxX(), castleRect.getMaxY() - 300).moveTowards(castleRect.getCenter(), 300)
		let posBtmRight0 = vec2(castleRect.getMaxX(), castleRect.getMinY()).moveTowards(castleRect.getCenter(), 300)
		let posBtmRight1 = vec2(castleRect.getMaxX() - 300, castleRect.getMinY()).moveTowards(castleRect.getCenter(), 300)
		let posBrmRight2 = vec2(castleRect.getMaxX(), castleRect.getMinY() + 300).moveTowards(castleRect.getCenter(), 300)
		let posTopLeft0 = vec2(castleRect.getMinX(), castleRect.getMaxY()).moveTowards(castleRect.getCenter(), 300)

		createUnit(p, ARMOR_SHOP_ID, posTopRight1, posTopRight1.angleTo(castleCenter))
		createUnit(p, MAGIC_ARMOR_SHOP_ID, posTopRight2, posTopRight2.angleTo(castleCenter))
		createUnit(p, ARMOR_RECIEPTS_SHOP_ID, posTopRight0, posTopRight0.angleTo(castleCenter))

		createUnit(p, WEAPON_SHOP_ID, posBrmRight2, posBrmRight2.angleTo(castleCenter))
		createUnit(p, POTIONS_SHOP_ID, posBtmRight1, posBtmRight1.angleTo(castleCenter))
		createUnit(p, RARE_RECIEPTS_SHOP_ID, posBtmRight0, posBtmRight0.angleTo(castleCenter))

		createUnit(p, LABORATORY_ID, posTopLeft0, posTopLeft0.angleTo(castleCenter))

	function getId() returns int
		return p.getId()

	private function addDebuffToBuildOnUnitDeath(unit u)
	// TODO: does not work
		if groupInBattle.contains(u)
			let iterator = buildingToUnitRelations.iterator()
			for buildingId from iterator
				if buildingToUnitRelations.get(buildingId) == u.getTypeId()
					let building = GetUnitsOfPlayerAndTypeId(p, buildingId).next()
					print("building name: " + building.getName())
					InstantDummyCaster.castTarget(players[PLAYER_NEUTRAL_AGGRESSIVE], RECOVERY_DEBUFF_ID, 1, Orders.tornado, building)
					break
			iterator.close()

	private function onHeroBought(unit selling, unit sold)
		if selling.getTypeId() == TAVERN_ID and sold.getOwner() == p
			hero = sold
			hero
				..setPos(castleHeroPoint)
				..addAbility(MOVE_TO_GLOBAL_MAP_ID)
			listenForHeroDies()
			p.selectSingle(hero)
			p.setCameraPosition(castleHeroPoint)
			createHeroOnMap(onGlobalMapPos)

	private function createHeroOnMap(vec2 pos)
		let forMapHero = heroesOnMapAndInBattleRelations.get(hero.getTypeId())
		heroOnMap = createUnit(p, forMapHero, pos, angle(220))
		// TODO: DEV
		// createItem(TREASURE_ID, pos)
		// createDestructable('B000', pos.polarOffset(angle(90), 100), angle(GetRandomDirectionDeg()), 1.1, 0)
		// createDestructable('B000', pos.polarOffset(angle(270), 100), angle(GetRandomDirectionDeg()), 1.1, 0)
		// createDestructable('B000', pos.polarOffset(angle(180), 100), angle(GetRandomDirectionDeg()), 1.1, 0)

	private function moveToCastle()
		pauseHeroOnMap(true)
		hero
			..setPos(castleHeroPoint)
			..show()
			..addAbility(MOVE_TO_GLOBAL_MAP_ID)
			..removeAbility(THE_ESCAPE_ID)
		p.setCameraPosition(castleHeroPoint)
		heroOnMap.hide()
		onGlobalMapPos = heroOnMap.getPos()
		p.selectSingle(hero)

	private function moveToGlobalMap()
		pauseHeroOnMap(false)
		hero
			..hide()
			..removeAbility(MOVE_TO_GLOBAL_MAP_ID)
		p.setCameraPosition(onGlobalMapPos)
		heroOnMap.show()
		p.selectSingle(heroOnMap)
		heroOnMap.setInvulnerable(true)
		doAfter(3, () -> heroOnMap.setInvulnerable(false))

	function createGroupAtPos(vec2 pos) returns group
		let allUnits = GetUnitsOfPlayerAll(p)
		let createdGroup = CreateGroup()
		for u in allUnits
			let t = u.getTypeId()
			if buildingToUnitRelations.has(t)
				let uId = buildingToUnitRelations.get(t)
				let nu = createUnit(p, uId, pos, angle(0))
				p.select(nu)
				createdGroup.addUnit(nu)
		return createdGroup

	function startBattleAt(vec2 pos)
		pauseHeroOnMap(true)
		onGlobalMapPos = heroOnMap.getPos()
		hero
			..setPos(pos)
			..addAbility(THE_ESCAPE_ID)
			..setAbilityCooldown(THE_ESCAPE_ID, 1, 60)
			..show()
		p
			..setCameraPosition(pos)
			..selectSingle(hero)
		groupInBattle = createGroupAtPos(pos)

	function battleVictory()
		pauseHeroOnMap(false)
		hero.queueAnimation("Cast")
		moveToGlobalMap()
		p.addLumber(1)
		for u in groupInBattle
			u.remove()

	function battleDefeat()
		moveToCastle()
		p.selectSingle(hero)
		for u in groupInBattle
			u.remove()

	function pauseHeroOnMap(boolean status)
		heroOnMap.setInvulnerable(status)
		if status
			heroOnMap.pause()
		else
			heroOnMap.unpause()

	private function initGroupBuildingPlaces()
		let small = GetUnitsOfPlayerAndTypeId(p, UnitIds.circleofpower)
		for sm from small
			let pos = sm.getPos()
			sm.remove()
			createUnit(p, UNIT_BUILD_PLACE_SMALL_ID, pos, angle(0))
		small.destr()

		let large = GetUnitsOfPlayerAndTypeId(p, UnitIds.circleofpowerlarge)
		for lg from large
			let pos = lg.getPos()
			lg.remove()
			createUnit(p, UNIT_BUILD_PLACE_LARGE_ID, pos, angle(0))
		large.destr()

	function isGroupAlive() returns bool
		var isAnyAlive = false
		for u in groupInBattle
			if u.isAlive()
				isAnyAlive = true
		return isAnyAlive

	function isHeroAlive() returns bool
		return hero.isAlive()

	function isAllGroupAlive() returns bool
		return isGroupAlive() or isHeroAlive()

	function isAllyOf(player pl) returns bool
		return p.isAllyOf(pl)

	function getPlayer() returns player
		return p

	function listenForHeroDies()
		EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
			if GetTriggerUnit() == hero
				let t = CreateTimer()
				let td = CreateTimerDialog(t)
					..setTitle("Hero revive")
					..setRealTimeRemaining(10)
					..display(true)
				doAfter(10) ->
					t.destr()
					td.destr()
					hero.revive(castleHeroPoint, true)
					hero.addAbility(MOVE_TO_GLOBAL_MAP_ID)
					p.setCameraQuickPosition(hero.getPos())
			if GetTriggerUnit() == heroOnMap
				createHeroOnMap(GetTriggerUnit().getPos())

	function moveToTreasury() // TODO: Use it!
		hero.setPos(gg_rct_Player0Treasury.getCenter())